# Retrospective Summary

This project was a collaborative effort to build the UVSIM simulator to read BasicML instructions. It allowed us to work as a team to implent the needed features for handling memory, running the CPU, and creating a interactive GUI to show the simulation. We designed it using the Model-View-Controller (MVC) architecture to help keep things organized and more maintainable. Throughout the process we tried to follow software design principles to help us learn about them while also improving our project.

## Performance

The final product of the project runs smoothly with minimal stutters, even when given larger instruction amounts. The UVSIM regularly executed the programs as expected and our error handling caught most edge cases. We validated and tested most of the core functionality through unit testing. This gave us confidence to know that our main components such as instruction execution, memory reading/writing, and I/O handling were working as we expected them to. While using the GUI, it remained responsive, and all the buttons and widgets worked as intended. Although this version of UVSIM is designed for educational purposes, the MVC architecture used allows for the ability for it to be expanded easily. Overall the program is stable, responsive, and loads and resets programs quickly. This reflects the effort we took in designing, organizing, and testing our code throughout the project.

## Future Road Map

To enhance the UVSim project beyond its current capabilities, several impactful features can be implemented. Introducing symbolic labels and a simple assembler would allow users to write programs using readable labels and variable names instead of raw opcodes and addresses, making development and debugging significantly easier. Adding execution breakpoints, memory watch functionality, and cycle counters would improve debugging and help users visualize how instructions affect memory over time. An interactive opcode tester could provide a hands-on way to explore instruction behavior in isolation, which is especially useful for beginners. Expanding the instruction set with conditional branching, stack operations, and indirect addressing would unlock more complex programming possibilities and align UVSim more closely with real-world low-level architectures. Finally, creating a plugin system for opcode handlers and optionally offering a web-based interface would future-proof the simulator and improve accessibility across platforms. 

## Key Takeaways

This project left our team with several takeaways throughout the design process. Early on, we began by considering our project's most likely users. The resulting profile of our expected users shaped our project's requirements, which in turn heavily influenced our design. Considering what kinds of users our project was meant for was critical for our project's early design and overall success. From that point, we were able to design and build the project while keeping separation of responsibilities in mind. Our initial design kept the code behind the model and the code behind the GUI separate, and later updates and refactoring added a controller to interface between them.  By keeping each functional piece of the code separate, we were able to modify and enhance specific components while causing minimal problems with existing code. This project structure concept was why we were able to develop our project as quickly as we could. As a team, we were flexible and supported each other throughout development. We changed roles after each sprint, so each member of our team was able to keep a clear idea of how the project was structured and what needed to be done during each sprint. This approach is unlikely to work well in a bigger project with more developers, but it worked well for our smaller team and gave each team member a better understanding of the project and process than would have been possible with roles remaining the same throughout the project. Overall, this project was an excellent learning experience and we are proud of the final product.
